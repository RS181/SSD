package Kademlia;

import BlockChain.Block;
import Cryptography.CryptoUtils;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Class that represents a kademlia Node in a  p2p network
 */
public class Node implements Serializable {
    private String nodeId; // Unique Id
    private String ipAddr;
    private int port;
    private RoutingTable routingTable;

    private Map<String, Block> localStorage;

    /**
     * Constructor for a Kademlia Node
     * @param ipAddr
     * @param port
     * @param createRoutingTable indicates whether to create or not the routing table
     *                           for this Kademlia Node
     */
    public Node(String ipAddr, int port, boolean createRoutingTable){
        this.ipAddr = ipAddr;
        this.port = port;
        this.nodeId = generateNodeId(ipAddr,port);
        if (createRoutingTable)
            this.routingTable = new RoutingTable(nodeId,ipAddr,port);
        localStorage = new HashMap<>();
    }

    /* Getter's */
    public String getNodeId() {
        return nodeId;
    }

    public String getIpAddr() {
        return ipAddr;
    }

    public int getPort() {
        return port;
    }

    public RoutingTable getRoutingTable() {
        return routingTable;
    }

    public Map<String, Block> getLocalStorage() {
        return localStorage;
    }

    /**
     * Generates a Node ID based on the IP address and port.
     * <p>
     * The Node ID is generated by applying the SHA-1 hash function to the
     * concatenation of the IP address and port. The result is then converted
     * to a binary string, from which the first {@code NUMBER_OF_BITS_NODE_ID} bits
     * are extracted to form the final Node ID.
     * <p>
     * This allows for flexibility in the size of the Node ID, which can be
     * configured via the {@code Constants.NUMBER_OF_BITS_NODE_ID} constant.
     *
     * For example, if {@code NUMBER_OF_BITS_NODE_ID = 16}, the first 16 bits of the
     * SHA-1 hash (in binary) will be returned.
     *
     * @param ipAddr The IP address of the node.
     * @param port   The port number of the node.
     * @return The generated Node ID as a binary string of length {@code NUMBER_OF_BITS_NODE_ID}.
     */

    public String generateNodeId(String ipAddr, int port) {
        String hashHex = CryptoUtils.getHash1(ipAddr + port); // SHA-1 hash in hex
        byte[] hashBytes = CryptoUtils.hexStringToByteArray(hashHex); // Convert hex string to bytes

        int numberOfBits = Constants.NUMBER_OF_BITS_NODE_ID;
        int numberOfBytesNeeded = (int) Math.ceil(numberOfBits / 8.0);

        if (hashBytes.length < numberOfBytesNeeded) {
            throw new IllegalArgumentException("Hash output is too short for the required number of bits");
        }

        StringBuilder binaryBuilder = new StringBuilder();
        for (int i = 0; i < numberOfBytesNeeded; i++) {
            binaryBuilder.append(String.format("%8s", Integer.toBinaryString(hashBytes[i] & 0xFF)).replace(' ', '0'));
        }

        // Truncate to the exact number of bits required
        return binaryBuilder.substring(0, numberOfBits);
    }

    /**
     * Adds node to Routing table
     * @param n
     */
    public  void addToRoutingTable(Node n){
        routingTable.addNodeToBucketList(n);
    }

    /**
     * Adds a block to local Storage
     * @param key
     * @param b
     */
    public void addToLocalStorage(String key, Block b){localStorage.put(key,b);}

    /**
     * Stores a key-value pair in the node's local storage if the key does not already exist.
     *
     * @param key   The key, which corresponds to a key id, used to identify the value.
     * @param value The value, which corresponds to a block, associated with the key.
     */
    public void storeKeyValuePair(String key,Block value){
        if (localStorage.get(key) == null)
            localStorage.put(key,value);
    }

    /**
     * Tries to get the block that corresponds to a certain key
     * @param key
     * @return a Block if there is a matching in nodes local storage, null otherwise
     */
    public Block getValue(String key){
        return localStorage.get(key);
    }

    @Override
    public boolean equals(Object object) {
        Node anotherNode= (Node) object;
        if (
                this.nodeId.equals(anotherNode.nodeId)
                && this.ipAddr.equals(anotherNode.ipAddr)
                && this.port == anotherNode.getPort()
        ) {
            return true;
        }
        return false;
    }
    @Override
    public int hashCode() {
        return Objects.hash(nodeId, ipAddr, port);
    }
    @Override
    public String toString() {
        return "[" +
                "Node Id = "       + nodeId + ", " +
                "Ip address = "  + ipAddr +   ", " +
                "Port = "        + port   +
                "]" ; //+
                //(routingTable != null ? routingTable.toString() : "");
    }
}
